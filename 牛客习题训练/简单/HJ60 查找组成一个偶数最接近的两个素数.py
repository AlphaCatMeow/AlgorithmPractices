# 描述
# 任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。

# 数据范围：输入的数据满足  4 ≤ n ≤ 1000 

# 输入描述：
# 输入一个大于2的偶数

# 输出描述：
# 从小到大输出两个素数

"""
质数（prime number）又称素数，有无限个。一个大于1的自然数，除了1和它本身外，不能被其他自然数（质数）整除，
换句话说就是该数除了1和它本身以外不再有其他的因数；否则称为合数。
根据算术基本定理，每一个比1大的整数，要么本身是一个质数，要么可以写成一系列质数的乘积；
而且如果不考虑这些质数在乘积中的顺序，那么写出来的形式是唯一的。最小的质数是2。
"""

# 判断一个数n是否为素数:
# 思路1：我们在每次得到一个数后，都去计算，去尝试因式分解它，看它除了1和自身之外还有没有其他因子，如果有其他因子，则因子必然成对存在，
# 除了1以外，任何合数最小的因子就是2，那最大的因子就是 n/2，因此可以使用循环判断n是否能被从2-n/2之间的整数整除。
# 实现方法1：


# 思路1延伸：在上面的基础上，其实不需要遍历到 n/2，只需要到 根号n（包含根号n） 就可以了。
# 实现方法2：


# 思路2：如果一个数不能整除比它小的任何素数，那么这个数就是素数，这种“打印”素数表的方法效率很低，不推荐使用，可以学习思想
# 实现方法3：


# 思路3：普通筛法——埃拉托斯特尼(Eratosthenes)筛法（百度百科对埃拉托斯特尼筛法简单描述：要得到自然数n以内的全部素数，必须把不大于根号n（包括根号n）的所有素数的倍数剔除，剩下的就是素数。）
"""
详细列出计算步骤如下：
列出2以后的所有序列：
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
标出序列中的第一个素数，也就是2，序列变成：
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
将剩下序列中，划掉2的倍数，序列变成：
2 3 5 7 9 11 13 15 17 19 21 23 25
如果这个序列中最大数小于最后一个标出的素数的平方，那么剩下的序列中所有的数都是素数，否则回到第二步。
本例中，因为25大于2的平方，我们返回第二步：
剩下的序列中第一个素数是3，将主序列中3的倍数划掉，主序列变成：
2 3 5 7 11 13 17 19 23 25
我们得到的素数有：2，3
25仍然大于3的平方，所以我们还要返回第二步：
序列中第一个素数是5，同样将序列中5的倍数划掉，主序列成了：
2 3 5 7 11 13 17 19 23
我们得到的素数有：2，3，5 。
因为23小于5的平方，跳出循环.
结论：2到25之间的素数是：2 3 5 7 11 13 17 19 23。
"""
# 实现方法4：


# 思路4：线性筛法——欧拉筛法
"""
我们再思考一下上面的埃拉托斯特尼筛法，会发现，在“剔除“非素数时，有些合数会重复赋值。这样就增加了复杂度，降低了效率。
比如：范围上限N = 16时
2是素数，剔除”2 的倍数“，他们是：4，6， 8，10， 12， 14， 16
3是素数，剔除”3 的倍数”，他们时，6，9，12，15
6，12是重复的。如何减少重复呢？
"""
# 实现方法5：


while True:
    try:
        n = int(input())
        m = int(n/2)
        a = 0
        for i in range(1,m+1):
            for j in range(2,i):
                if i%j ==0 or (n-i)%j == 0:
                    break
            else:
                a=i
        print(a)
        print(n-a)
    except:
        break